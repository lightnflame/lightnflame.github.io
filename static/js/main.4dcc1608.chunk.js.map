{"version":3,"sources":["BabylonScene.tsx","BViewer.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["BabylonScene","scene","engine","canvas","onResizeWindow","resize","forceUpdate","onCanvasLoaded","c","this","BABYLON","props","engineOptions","adaptToDeviceRatio","onSceneMount","console","error","window","addEventListener","removeEventListener","width","height","opts","undefined","innerWidth","innerHeight","ref","touchaction","React","Component","BViewer","eArgs","camera","Math","PI","Zero","wheelPrecision","lowerRadiusLimit","upperRadiusLimit","attachControl","light","intensity","diffuse","clearColor","mat","diffuseTexture","hasAlpha","backFaceCulling","emissiveColor","Magenta","sphere","CreateSphere","diameter","material","position","rotation","y","lensMat","diffuseColor","alpha","frameMat","Black","armLMat","wireframe","armRMat","Blue","lensMat2","frameMat2","groundMat","groundDiffTex","uScale","vScale","groundBumpTex","bumpTexture","ground","CreateGround","subdivisions","wireMat","ImportMesh","meshes","forEach","m","scaling","actionManager","registerAction","OnPickUpTrigger","x","name","dispose","al","rotate","X","LOCAL","z","m0","log","find","el","runRenderLoop","render","antialias","App","className","Boolean","location","hostname","match","ReactDOM","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.4dcc1608.chunk.js","sourcesContent":["// BabylonScene: Initialize Babylon Engine, Scene, and canvas\nimport React from 'react';\nimport * as BABYLON from 'babylonjs';\n\nexport type SceneEventArgs = {\n  engine: BABYLON.Engine,\n  scene:  BABYLON.Scene,\n  canvas: HTMLCanvasElement\n};\n\nexport type SceneProps = {\n  engineOptions?:      BABYLON.EngineOptions,\n  adaptToDeviceRatio?: boolean,\n  onSceneMount?:       (args: SceneEventArgs) => void,\n  width?:              number,\n  height?:             number\n};\n\nexport class BabylonScene extends React.Component<SceneProps & React.HTMLAttributes<HTMLCanvasElement>, {}> {\n  private scene:  BABYLON.Scene;\n  private engine: BABYLON.Engine;\n  private canvas: HTMLCanvasElement;\n\n  onResizeWindow = () => {\n    if (this.engine) {\n      this.engine.resize();\n      this.forceUpdate();\n    }\n  }\n\n  componentDidMount () {\n    this.engine = new BABYLON.Engine(\n        this.canvas,\n        true,  // antialias\n        this.props.engineOptions,\n        this.props.adaptToDeviceRatio\n    );\n\n    let scene = new BABYLON.Scene(this.engine);\n    this.scene = scene;\n\n    if (typeof this.props.onSceneMount === 'function') {  // ./BViewer.tsx\n      this.props.onSceneMount({  // Load scene objects\n        scene,\n        engine: this.engine,\n        canvas: this.canvas\n      });\n    } else {\n      console.error('onSceneMount function not available');\n    }\n\n    // Resize the babylon engine when the window is resized\n    window.addEventListener('resize', this.onResizeWindow);\n  }\n\n  componentWillUnmount () {\n    window.removeEventListener('resize', this.onResizeWindow);\n  }\n\n  onCanvasLoaded = (c : HTMLCanvasElement) => {\n    if (c !== null) {\n      this.canvas = c;\n    }\n  }\n\n  render () {\n    // 'rest' can contain additional properties that you can flow through to canvas:\n    // (id, className, etc.)\n    // let { width, height, ...rest } = this.props;\n    let { width, height } = this.props;\n    let opts: any = {};\n\n    if (width !== undefined && height !== undefined) {\n      opts.width  = width;\n      opts.height = height;\n    } else {\n      opts.width  = window.innerWidth;\n      opts.height = window.innerHeight;\n    }\n\n    return (\n      <canvas\n        {...opts}\n        ref={this.onCanvasLoaded}\n        touchaction=\"none\"\n      />\n    )\n  }\n}\n","// BViewer, scene objects - will be called back by BabylonScene after engine startup\nimport React from 'react';\nimport * as BABYLON from 'babylonjs';\nimport 'babylonjs-loaders';\nimport { BabylonScene, SceneEventArgs } from './BabylonScene';\n\nexport const BViewer: React.FC = () => {\n  const onSceneMount = (eArgs: SceneEventArgs) => {\n    const { canvas, scene, engine } = eArgs;\n    const ANIMATION_ON = false;\n\n    // This creates and positions a free camera (non-mesh)\n    //const camera = new BABYLON.FreeCamera(\"camera1\", new BABYLON.Vector3(0, 0, -1.4), scene);\n    const camera = new BABYLON.ArcRotateCamera(\"camera1\", -Math.PI/2, Math.PI/2, 2.3, BABYLON.Vector3.Zero(), scene);\n    camera.wheelPrecision = 50;\n    camera.lowerRadiusLimit = 2;  // when maximum size\n    camera.upperRadiusLimit = 6;  // when minimum size\n\n    //camera.setTarget(BABYLON.Vector3.Zero());  // This targets the camera to scene origin\n    camera.attachControl(canvas, true);  // This attaches the camera to the canvas\n\n    // This creates a light, aiming 0,1,0 - to the sky (non-mesh)\n    const light = new BABYLON.HemisphericLight(\"light1\", new BABYLON.Vector3(0, 2, -1), scene);\n    //const light = new BABYLON.PointLight(\"Omni\", new BABYLON.Vector3(1,1,1), scene);\n\n    // Default intensity is 1. Let's dim the light a small amount\n    light.intensity = 0.9;\n    light.diffuse = new BABYLON.Color3(1, 1, 1);\n    //Light direction is directly down from a position one unit up, slow decay\n    /*\n    const light2 = new BABYLON.SpotLight(\"light2\", new BABYLON.Vector3(-.5, 1, -.5), new BABYLON.Vector3(0, -1, 0), Math.PI / 2, 10, scene);\n    light2.diffuse = new BABYLON.Color3(1, 0, 0);\n    light2.specular = new BABYLON.Color3(0, 1, 0);\n     */\n\n    // Move the light with the camera\n    // scene.registerBeforeRender(() => {\n    //  light.position = camera.position;\n    // });\n\n    scene.clearColor = new BABYLON.Color4(0,0,0, 0);  // transparent background, white color will make an outline\n\n    const mat = new BABYLON.StandardMaterial(\"eye\", scene);\n    mat.diffuseTexture = new BABYLON.Texture(\"http://i.imgur.com/5AbIaih.png\", scene);\n    mat.diffuseTexture.hasAlpha = true;\n    mat.backFaceCulling = false;\n    mat.emissiveColor = BABYLON.Color3.Magenta();\n\n    // Our built-in 'sphere' shape. Params: name, subdivs, size, scene\n    //const sphere = BABYLON.Mesh.CreateSphere(\"sphere1\", 16, 2, scene);\n    const sphere = BABYLON.MeshBuilder.CreateSphere(\"sphere1\", {diameter:.15}, scene);\n    sphere.material = mat;\n    sphere.position = new BABYLON.Vector3(.32, -.325, 0);  // Move the sphere upward 1/2 its height\n    sphere.rotation.y = -Math.PI/2;\n    if (ANIMATION_ON) {\n      scene.registerBeforeRender(() => {  // animation\n        sphere.rotation.y -= .005;\n      });\n    }\n\n    const lensMat = new BABYLON.StandardMaterial(\"lensMat\", scene);\n    lensMat.diffuseColor = BABYLON.Color3.Magenta();\n    lensMat.alpha = .5;\n    const frameMat = new BABYLON.StandardMaterial(\"frameMat\", scene);\n    frameMat.diffuseColor = BABYLON.Color3.Black();\n    const armLMat = new BABYLON.StandardMaterial(\"armLMat\", scene);\n    armLMat.emissiveColor = new BABYLON.Color3(.5, 0, 0);\n    armLMat.wireframe = true;\n    const armRMat = new BABYLON.StandardMaterial(\"armLMat\", scene);\n    armRMat.emissiveColor = BABYLON.Color3.Blue();\n    armRMat.wireframe = true;\n\n    const lensMat2 = new BABYLON.StandardMaterial(\"lensMat2\", scene);\n    lensMat2.diffuseColor = BABYLON.Color3.Black();\n    lensMat2.alpha = .5;\n    const frameMat2 = new BABYLON.StandardMaterial(\"frameMat2\", scene);\n    frameMat2.diffuseColor = BABYLON.Color3.Black();\n    \n    const groundMat = new BABYLON.StandardMaterial(\"groundMat\", scene);\n    //groundMat.diffuseColor = new BABYLON.Color3(0/255, 128/255, 128/255);\n    const groundDiffTex = new BABYLON.Texture('http://i.imgur.com/Wk1cGEq.png', scene);\n    groundDiffTex.uScale = 4;\n    groundDiffTex.vScale = 4;\n    groundMat.diffuseTexture = groundDiffTex;\n    const groundBumpTex = new BABYLON.Texture('http://i.imgur.com/wGyk6os.png', scene);\t\n    groundBumpTex.uScale = 4;\n    groundBumpTex.vScale = 4;\n    groundMat.bumpTexture = groundBumpTex;\n    //groundMat.wireframe = true;\n\n    // Our built-in 'ground' shape. Params: name, width, depth, subdivs, scene\n    // const ground = BABYLON.Mesh.CreateGround(\"ground1\", 6, 6, 2, scene);\n    const ground = BABYLON.MeshBuilder.CreateGround(\"ground1\", {height: 1, width: 1, subdivisions: 10}, scene);\n    ground.material = groundMat;\n    ground.position.y = -.4;\n\n    const MODEL_PATH = \"./models/\";\n\n    // Available Meshes: https://doc.babylonjs.com/resources/meshes_to_load\n    // Append glTF model to scene.\n    //BABYLON.SceneLoader.Append(\"https://www.babylonjs.com/Assets/DamagedHelmet/glTF/\", \"DamagedHelmet.gltf\",\n    //BABYLON.SceneLoader.Append(\"./\", \"BoseAlto.obj\", scene, scene => {\n    // In this case we're loading our mesh from an external source.\n    const wireMat = new BABYLON.StandardMaterial(\"wireMat\", scene);\n    wireMat.emissiveColor = new BABYLON.Color3(0/255, 255/255, 255/255);\n    wireMat.wireframe = true;\n    wireMat.alpha = .1;\n\n    BABYLON.SceneLoader.ImportMesh(\"\", MODEL_PATH, \"face.obj\", scene, meshes => {\n      const sc = .0052;\n      meshes.forEach(m => {\n        // console.log(m.name);\n        m.material = wireMat;\n        m.rotation.y = Math.PI;\n        m.scaling = new BABYLON.Vector3(sc, sc, sc);\n        m.position = new BABYLON.Vector3(0, .13, .1);\n\n        m.actionManager = new BABYLON.ActionManager(scene);\n        m.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickUpTrigger, () => {\n          if (m.material) {\n            m.material.wireframe = !m.material.wireframe;\n            m.material.alpha = m.material.wireframe ? .1 : .3;\n          }\n        }));\n\n        if (ANIMATION_ON) {\n          scene.registerBeforeRender(() => {  // animation\n            m.rotation.y -= .001;\n          })\n        }\n      });\n    });\n\n    BABYLON.SceneLoader.ImportMesh(\"\", MODEL_PATH, \"BoseAlto.obj\", scene, meshes => {\n      const sc = 5;\n      meshes.forEach(m => {\n        //console.log(m.name);\n        m.rotation.y = Math.PI;\n        m.rotation.x = -Math.PI/8;\n        m.scaling = new BABYLON.Vector3(sc, sc, sc);\n        m.position = new BABYLON.Vector3(0, .22, .1);\n        if (m.name === \"hdrSkyBox\") {\n          m.dispose();\n        }\n        switch (m.name) {\n          case \"_mm1\":              m.material = lensMat;   break;\n          case \"Alto_Frames\":       m.material = frameMat;  break;\n          case \"Alto_Frame_Arm_L\":  m.material = armLMat;   break;\n          case \"Alto_Frame_Arm_R\":  m.material = armRMat;   break;\n          default:\n        }\n        m.actionManager = new BABYLON.ActionManager(scene);\n        m.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickUpTrigger, () => {\n          if (m.material) {\n            if (m.name === \"_mm1\") {\n              let al = m.material.alpha;\n              al -= .1;\n              if (al <= 0)\n                al = 1;\n              m.material.alpha = al;\n            } else {\n              m.material.wireframe = !m.material.wireframe;\n            }\n          }\n        }));\n\n        if (ANIMATION_ON) {\n          scene.registerBeforeRender(() => {  // animation\n            m.rotation.y -= .001;\n          })\n        }\n      });\n    });\n\n    BABYLON.SceneLoader.ImportMesh(\"\", MODEL_PATH, \"BoseAlto.obj\", scene, meshes => {\n      const sc = 1;\n      meshes.forEach(m => {\n        m.material = (m.name === \"_mm1\") ? lensMat2 : frameMat2;\n        m.rotation.y = Math.PI;\n        m.scaling  = new BABYLON.Vector3(sc, sc, sc);\n        m.position = new BABYLON.Vector3(0,-.095,-.097);\n      });\n    });\n\n    BABYLON.SceneLoader.ImportMesh(\"\", \"https://models.babylonjs.com/Lee-Perry-Smith-Head/\", \"head.babylon\",\n      scene, meshes => {\n      const m = meshes[0];\n      m.position.y = -.4;\n      m.actionManager = new BABYLON.ActionManager(scene);\n      m.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickUpTrigger, () => {\n        if (m.material) {\n          m.material.wireframe = !m.material.wireframe;\n          m.material.alpha = m.material.wireframe ? .1 : 1;\n        }\n      }));\n    });\n\n    BABYLON.SceneLoader.ImportMesh(\"\", \"https://models.babylonjs.com/Skull/\", \"skull.babylon\",\n      scene, meshes => {\n      const sc = .0036;\n      const m = meshes[0];\n      m.scaling  = new BABYLON.Vector3(sc, sc, sc);\n      m.position = new BABYLON.Vector3(.32, -.14, -.05);\n      m.actionManager = new BABYLON.ActionManager(scene);\n      m.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickUpTrigger, () => {\n        m.rotation.y += Math.PI/4;\n      }));\n    });\n\n    BABYLON.SceneLoader.ImportMesh(\"\", MODEL_PATH, \"BoseAlto.obj\", scene, meshes => {\n      const sc = 1;\n      meshes.forEach(m => {\n        m.material = (m.name === \"_mm1\") ? lensMat2 : frameMat2;\n        m.rotation.x = Math.PI/10;\n        m.rotation.y = Math.PI;\n        m.scaling  = new BABYLON.Vector3(sc, sc, sc);\n        m.position = new BABYLON.Vector3(.32,-.1,-.086);\n        //m.rotate(BABYLON.Axis.X, Math.PI/10, BABYLON.Space.LOCAL);\n      });\n    });\n\n    BABYLON.SceneLoader.ImportMesh(\"\", \"https://models.babylonjs.com/\", \"seagulf.glb\", scene, meshes => {\n      const sc = .0004;\n      meshes[0].scaling  = new BABYLON.Vector3(sc, sc, sc);\n      meshes[0].position = new BABYLON.Vector3(-.3, -.194, 0.25);\n    });\n\n    BABYLON.SceneLoader.ImportMesh(\"\", MODEL_PATH, \"BoseRondo.obj\", scene, meshes => {\n      const sc = 1;\n      meshes.forEach(m => {\n        m.material = (m.name === \"_mm1\") ? lensMat2 : frameMat2;\n        m.rotation.y = Math.PI;\n        m.scaling  = new BABYLON.Vector3(sc, sc, sc);\n        m.position = new BABYLON.Vector3(-.3,-.11,-.016);\n        m.rotate(BABYLON.Axis.X, -Math.PI/2+Math.PI/10, BABYLON.Space.LOCAL);\n      });\n    });\n\n    BABYLON.SceneLoader.ImportMesh(\"\", MODEL_PATH, \"BoseRondo.obj\", scene, meshes => {\n      const sc = 1;\n      meshes.forEach(m => {\n        //console.log(m.name);\n        m.rotation.y = Math.PI*1.2;\n        m.rotation.x = -Math.PI/20;\n        m.material = (m.name === \"_mm1\") ? lensMat2 : frameMat2;\n        m.scaling  = new BABYLON.Vector3(sc, sc, sc);\n        m.position = new BABYLON.Vector3(0,-.375,-.22);\n        if (m.name === \"Rondo_Frame_Arm_L\") {\n          m.rotation.y += Math.PI/4;\n          m.position.x -= .02;\n          m.position.z -= .062;\n        }\n      });\n    });\n\n    BABYLON.SceneLoader.ImportMesh(\"\", MODEL_PATH, \"BaseballCap.glb\", scene, meshes => {\n      const sc = .048;\n      const m0 = meshes[0];\n      console.log(m0.name);  // __root__\n      m0.rotation = new BABYLON.Vector3(-Math.PI/2.6, 0, 0);\n      m0.scaling  = new BABYLON.Vector3(sc, sc*1.08, sc);\n      m0.position = new BABYLON.Vector3(0,.57,.2);\n      const m = meshes.find(el => el.name === \"10131_BaseballCap_v2_L3\");\n      if (m && m.material) {\n        m.actionManager = new BABYLON.ActionManager(scene);\n        m.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickUpTrigger, () => {\n          if (m.material) {\n            m.material.wireframe = !m.material.wireframe;\n            m.material.alpha = m.material.wireframe ? .1 : 1;\n          }\n        }));\n      }\n    });\n\n    /*\n    BABYLON.SceneLoader.ImportMesh(\"\", MODEL_PATH, \"BaseballCap.obj\", scene, meshes => {\n      const sc = .048;\n      meshes.forEach(m => {\n        console.log(m.name);\n        m.rotation = new BABYLON.Vector3(-Math.PI/2.6, 0, 0);\n        m.scaling  = new BABYLON.Vector3(sc, sc*1.08, sc);\n        m.position = new BABYLON.Vector3(0,.57,.2);\n        const mat = new BABYLON.StandardMaterial(\"cap\", scene);\n        mat.diffuseTexture = new BABYLON.Texture(MODEL_PATH + \"BaseballCap.jpg\", scene);\n        mat.wireframe = true;\n        m.material = mat;\n      });\n    });\n     */\n\n    /*\n    // Key Controls\n    const mapK = {};  // object for multiple key presses\n    scene.actionManager = new BABYLON.ActionManager(scene);\n\n    scene.actionManager.registerAction(\n      new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, evt => {\n        mapK[evt.sourceEvent.key] = evt.sourceEvent.type === \"keydown\";\n      })\n    );\n    scene.actionManager.registerAction(\n      new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyUpTrigger, evt => {\n        mapK[evt.sourceEvent.key] = evt.sourceEvent.type === \"keydown\";\n      })\n    );\n\n    scene.registerAfterRender(() => {\n      if ((mapK[\"w\"] || mapK[\"W\"])) {\n        armLMat.wireframe = !armLMat.wireframe;\n      }\n      if ((mapK[\"z\"] || mapK[\"Z\"])) {\n        armRMat.wireframe = !armRMat.wireframe;\n      }\n    });\n     */\n\n    engine.runRenderLoop(() => {\n      if (scene) {\n        scene.render();\n      }\n    });\n  }\n\n  return (\n    <BabylonScene\n      onSceneMount={onSceneMount}\n      engineOptions={{alpha: true, antialias: true}}\n      width={800}\n      height={800}\n    />\n  )\n}\n","import React from 'react';\nimport './App.scss';\nimport { BViewer } from './BViewer';\n\nconst App: React.FC = () => {\n  return (\n    <div className=\"App\">\n      <BViewer />\n      <h1>SPACETIMEQ INC</h1>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}