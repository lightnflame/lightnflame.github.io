{"version":3,"sources":["BabylonScene.tsx","BViewer.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["BabylonScene","scene","engine","canvas","onResizeWindow","resize","forceUpdate","onCanvasLoaded","c","this","BABYLON","props","engineOptions","adaptToDeviceRatio","onSceneMount","console","error","window","addEventListener","removeEventListener","width","height","opts","undefined","innerWidth","innerHeight","ref","touchaction","React","Component","BViewer","e","camera","Math","PI","Zero","wheelPrecision","attachControl","light","intensity","diffuse","clearColor","mat","diffuseTexture","hasAlpha","backFaceCulling","emissiveColor","Magenta","sphere","CreateSphere","diameter","material","position","registerBeforeRender","rotation","y","lensMat","diffuseColor","alpha","frameMat","Black","armLMat","wireframe","armRMat","Blue","lensMat2","frameMat2","groundMat","groundDiffTex","uScale","vScale","groundBumpTex","bumpTexture","ground","CreateGround","subdivisions","wireMat","ImportMesh","meshes","forEach","m","scaling","x","name","dispose","rotate","X","LOCAL","z","runRenderLoop","render","antialias","App","className","Boolean","location","hostname","match","ReactDOM","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.2c7d6ae7.chunk.js","sourcesContent":["import React from 'react';\nimport * as BABYLON from 'babylonjs';\n\nexport type SceneEventArgs = {\n  engine: BABYLON.Engine,\n  scene:  BABYLON.Scene,\n  canvas: HTMLCanvasElement\n};\n\nexport type SceneProps = {\n  engineOptions?:      BABYLON.EngineOptions,\n  adaptToDeviceRatio?: boolean,\n  onSceneMount?:       (args: SceneEventArgs) => void,\n  width?:              number,\n  height?:             number\n};\n\nexport class BabylonScene extends React.Component<SceneProps & React.HTMLAttributes<HTMLCanvasElement>, {}> {\n  private scene:  BABYLON.Scene;\n  private engine: BABYLON.Engine;\n  private canvas: HTMLCanvasElement;\n\n  onResizeWindow = () => {\n    if (this.engine) {\n      this.engine.resize();\n      this.forceUpdate();\n    }\n  }\n\n  componentDidMount () {\n    this.engine = new BABYLON.Engine(\n        this.canvas,\n        true,  // antialias\n        this.props.engineOptions,\n        this.props.adaptToDeviceRatio\n    );\n\n    let scene = new BABYLON.Scene(this.engine);\n    this.scene = scene;\n\n    if (typeof this.props.onSceneMount === 'function') {\n      this.props.onSceneMount({\n        scene,\n        engine: this.engine,\n        canvas: this.canvas\n      });\n    } else {\n      console.error('onSceneMount function not available');\n    }\n\n    // Resize the babylon engine when the window is resized\n    window.addEventListener('resize', this.onResizeWindow);\n  }\n\n  componentWillUnmount () {\n    window.removeEventListener('resize', this.onResizeWindow);\n  }\n\n  onCanvasLoaded = (c : HTMLCanvasElement) => {\n    if (c !== null) {\n      this.canvas = c;\n    }\n  }\n\n  render () {\n    // 'rest' can contain additional properties that you can flow through to canvas:\n    // (id, className, etc.)\n    // let { width, height, ...rest } = this.props;\n    let { width, height } = this.props;\n    let opts: any = {};\n\n    if (width !== undefined && height !== undefined) {\n      opts.width = width;\n      opts.height = height;\n    } else {\n      opts.width = window.innerWidth;\n      opts.height = window.innerHeight;\n    }\n\n    return (\n      <canvas\n        {...opts}\n        ref={this.onCanvasLoaded}\n        touchaction=\"none\"\n      />\n    )\n  }\n}\n","import React from 'react';\nimport * as BABYLON from 'babylonjs';\nimport 'babylonjs-loaders';\nimport { BabylonScene, SceneEventArgs } from './BabylonScene';\n\nexport const BViewer: React.FC = () => {\n  const onSceneMount = (e: SceneEventArgs) => {\n    const { canvas, scene, engine } = e;\n\n    // This creates and positions a free camera (non-mesh)\n    //let camera = new BABYLON.FreeCamera(\"camera1\", new BABYLON.Vector3(0, 0, -1.4), scene);\n    let camera = new BABYLON.ArcRotateCamera(\"camera1\", -Math.PI/2, Math.PI/2, 1.7, BABYLON.Vector3.Zero(), scene);\n    camera.wheelPrecision = 50;\n\n    //camera.setTarget(BABYLON.Vector3.Zero());  // This targets the camera to scene origin\n    camera.attachControl(canvas, true);  // This attaches the camera to the canvas\n\n    // This creates a light, aiming 0,1,0 - to the sky (non-mesh)\n    let light = new BABYLON.HemisphericLight(\"light1\", new BABYLON.Vector3(0, 2, -1), scene);\n    //let light = new BABYLON.PointLight(\"Omni\", new BABYLON.Vector3(1,1,1), scene);\n\n    // Default intensity is 1. Let's dim the light a small amount\n    light.intensity = 0.9;\n    light.diffuse = new BABYLON.Color3(1, 1, 1);\n    //Light direction is directly down from a position one unit up, slow decay\n    /*\n    let light2 = new BABYLON.SpotLight(\"light2\", new BABYLON.Vector3(-.5, 1, -.5), new BABYLON.Vector3(0, -1, 0), Math.PI / 2, 10, scene);\n    light2.diffuse = new BABYLON.Color3(1, 0, 0);\n    light2.specular = new BABYLON.Color3(0, 1, 0);\n     */\n\n    // Move the light with the camera\n    // scene.registerBeforeRender(() => {\n    //  light.position = camera.position;\n    // });\n\n    scene.clearColor = new BABYLON.Color4(0,0,0, 0);  // transparent background, white color will make an outline\n\n    let mat = new BABYLON.StandardMaterial(\"eye\", scene);\n    mat.diffuseTexture = new BABYLON.Texture(\"http://i.imgur.com/5AbIaih.png\", scene);\n    mat.diffuseTexture.hasAlpha = true;\n    mat.backFaceCulling = false;\n    mat.emissiveColor = BABYLON.Color3.Magenta();\n\n    // Our built-in 'sphere' shape. Params: name, subdivs, size, scene\n    //let sphere = BABYLON.Mesh.CreateSphere(\"sphere1\", 16, 2, scene);\n    let sphere = BABYLON.MeshBuilder.CreateSphere(\"sphere1\", {diameter:.15}, scene);\n    sphere.material = mat;\n    sphere.position = new BABYLON.Vector3(.32, -.325, 0);  // Move the sphere upward 1/2 its height\n    //sphere.rotation.y = -Math.PI/2;\n    scene.registerBeforeRender(() => {  // animation\n      sphere.rotation.y -= .005;\n    });\n\n    let lensMat = new BABYLON.StandardMaterial(\"lensMat\", scene);\n    lensMat.diffuseColor = BABYLON.Color3.Magenta();\n    lensMat.alpha = .5;\n    let frameMat = new BABYLON.StandardMaterial(\"frameMat\", scene);\n    frameMat.diffuseColor = BABYLON.Color3.Black();\n    let armLMat = new BABYLON.StandardMaterial(\"armLMat\", scene);\n    armLMat.emissiveColor = new BABYLON.Color3(.5, 0, 0);\n    armLMat.wireframe = true;\n    let armRMat = new BABYLON.StandardMaterial(\"armLMat\", scene);\n    armRMat.emissiveColor = BABYLON.Color3.Blue();\n    armRMat.wireframe = true;\n\n    let lensMat2 = new BABYLON.StandardMaterial(\"lensMat2\", scene);\n    lensMat2.diffuseColor = BABYLON.Color3.Black();\n    lensMat2.alpha = .5;\n    let frameMat2 = new BABYLON.StandardMaterial(\"frameMat2\", scene);\n    frameMat2.diffuseColor = BABYLON.Color3.Black();\n    \n    let groundMat = new BABYLON.StandardMaterial(\"groundMat\", scene);\n    //groundMat.diffuseColor = new BABYLON.Color3(0/255, 128/255, 128/255);\n    let groundDiffTex = new BABYLON.Texture('http://i.imgur.com/Wk1cGEq.png', scene);\n    groundDiffTex.uScale = 4;\n    groundDiffTex.vScale = 4;\n    groundMat.diffuseTexture = groundDiffTex;\n    let groundBumpTex = new BABYLON.Texture('http://i.imgur.com/wGyk6os.png', scene);\t\n    groundBumpTex.uScale = 4;\n    groundBumpTex.vScale = 4;\n    groundMat.bumpTexture = groundBumpTex;\n    //groundMat.wireframe = true;\n    // Our built-in 'ground' shape. Params: name, width, depth, subdivs, scene\n    // let ground = BABYLON.Mesh.CreateGround(\"ground1\", 6, 6, 2, scene);\n    let ground = BABYLON.MeshBuilder.CreateGround(\"ground1\", {height: 1, width: 1, subdivisions: 10}, scene);\n    ground.material = groundMat;\n    ground.position.y = -.4;\n\n    const MODEL_PATH = \"./models/\";\n\n    // Available Meshes: https://doc.babylonjs.com/resources/meshes_to_load\n    // Append glTF model to scene.\n    //BABYLON.SceneLoader.Append(\"https://www.babylonjs.com/Assets/DamagedHelmet/glTF/\", \"DamagedHelmet.gltf\",\n    //BABYLON.SceneLoader.Append(\"./\", \"BoseAlto.obj\", scene, scene => {\n    // In this case we're loading our mesh from an external source.\n    let wireMat = new BABYLON.StandardMaterial(\"wireMat\", scene);\n    wireMat.emissiveColor = new BABYLON.Color3(0/255, 255/255, 255/255);\n    wireMat.wireframe = true;\n    wireMat.alpha = .1;\n\n    BABYLON.SceneLoader.ImportMesh(\"\", MODEL_PATH, \"face.obj\", scene, meshes => {\n      const sc = .0052;\n      meshes.forEach(m => {\n        // console.log(m.name);\n        m.material = wireMat;\n        m.rotation.y = Math.PI;\n        m.scaling = new BABYLON.Vector3(sc, sc, sc);\n        m.position = new BABYLON.Vector3(0, .13, .1);\n        scene.registerBeforeRender(function() {  // animation\n          m.rotation.y -= .001;\n        })\n      });\n    });\n\n    BABYLON.SceneLoader.ImportMesh(\"\", MODEL_PATH, \"BoseAlto.obj\", scene, meshes => {\n      const sc = 5;\n      meshes.forEach(m => {\n        //console.log(m.name);\n        m.rotation.y = Math.PI;\n        m.rotation.x = -Math.PI/8;\n        m.scaling = new BABYLON.Vector3(sc, sc, sc);\n        m.position = new BABYLON.Vector3(0, .22, .1);\n        if (m.name === \"hdrSkyBox\") {\n          m.dispose();\n        }\n        switch (m.name) {\n          case \"_mm1\":              m.material = lensMat;   break;\n          case \"Alto_Frames\":       m.material = frameMat;  break;\n          case \"Alto_Frame_Arm_L\":  m.material = armLMat;   break;\n          case \"Alto_Frame_Arm_R\":  m.material = armRMat;   break;\n          default:\n        }\n        scene.registerBeforeRender(function() {  // animation\n          m.rotation.y -= .001;\n        })\n      });\n    });\n\n    BABYLON.SceneLoader.ImportMesh(\"\", MODEL_PATH, \"BoseAlto.obj\", scene, meshes => {\n      const sc = 1;\n      meshes.forEach(m => {\n        m.material = (m.name === \"_mm1\") ? lensMat2 : frameMat2;\n        m.rotation.y = Math.PI;\n        m.scaling = new BABYLON.Vector3(sc, sc, sc);\n        m.position = new BABYLON.Vector3(0,-.095,-.097);\n      });\n    });\n\n    BABYLON.SceneLoader.ImportMesh(\"\", \"https://models.babylonjs.com/Lee-Perry-Smith-Head/\", \"head.babylon\",\n      scene, meshes => {\n      meshes[0].position.y = -.4;\n    });\n\n    BABYLON.SceneLoader.ImportMesh(\"\", \"https://models.babylonjs.com/Skull/\", \"skull.babylon\",\n      scene, meshes => {\n      const sc = .0036;\n      let m = meshes[0];\n      m.scaling = new BABYLON.Vector3(sc, sc, sc);\n      m.position = new BABYLON.Vector3(.32, -.14, -.05);\n    });\n\n    BABYLON.SceneLoader.ImportMesh(\"\", MODEL_PATH, \"BoseAlto.obj\", scene, meshes => {\n      const sc = 1;\n      meshes.forEach(m => {\n        m.material = (m.name === \"_mm1\") ? lensMat2 : frameMat2;\n        m.rotation.x = Math.PI/10;\n        m.rotation.y = Math.PI;\n        m.scaling = new BABYLON.Vector3(sc, sc, sc);\n        m.position = new BABYLON.Vector3(.32,-.1,-.086);\n        //m.rotate(BABYLON.Axis.X, Math.PI/10, BABYLON.Space.LOCAL);\n      });\n    });\n\n    BABYLON.SceneLoader.ImportMesh(\"\", \"https://models.babylonjs.com/\", \"seagulf.glb\", scene, meshes => {\n      const sc = .0004;\n      meshes[0].scaling = new BABYLON.Vector3(sc, sc, sc);\n      meshes[0].position = new BABYLON.Vector3(-.3, -.194, 0.25);\n    });\n\n    BABYLON.SceneLoader.ImportMesh(\"\", MODEL_PATH, \"BoseRondo.obj\", scene, meshes => {\n      const sc = 1;\n      meshes.forEach(m => {\n        m.material = (m.name === \"_mm1\") ? lensMat2 : frameMat2;\n        m.rotation.y = Math.PI;\n        m.scaling = new BABYLON.Vector3(sc, sc, sc);\n        m.position = new BABYLON.Vector3(-.3,-.11,-.016);\n        m.rotate(BABYLON.Axis.X, -Math.PI/2+Math.PI/10, BABYLON.Space.LOCAL);\n      });\n    });\n\n    BABYLON.SceneLoader.ImportMesh(\"\", MODEL_PATH, \"BoseRondo.obj\", scene, meshes => {\n      const sc = 1;\n      meshes.forEach(m => {\n        //console.log(m.name);\n        m.rotation.y = Math.PI*1.2;\n        m.rotation.x = -Math.PI/20;\n        m.material = (m.name === \"_mm1\") ? lensMat2 : frameMat2;\n        m.scaling = new BABYLON.Vector3(sc, sc, sc);\n        m.position = new BABYLON.Vector3(0,-.375,-.22);\n        if (m.name === \"Rondo_Frame_Arm_L\") {\n          m.rotation.y += Math.PI/4;\n          m.position.x -= .02;\n          m.position.z -= .062;\n        }\n      });\n    });\n\n    engine.runRenderLoop(() => {\n      if (scene) {\n        scene.render();\n      }\n    });\n  }\n\n  return (\n    <BabylonScene\n      onSceneMount={onSceneMount}\n      engineOptions={{alpha: true, antialias: true}}\n      width={800}\n      height={800}\n    />\n  )\n}\n","import React from 'react';\nimport './App.scss';\nimport { BViewer } from './BViewer';\n\nconst App: React.FC = () => {\n  return (\n    <div className=\"App\">\n      <BViewer />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}